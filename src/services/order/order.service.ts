import { Inject, Service } from "typedi";
import { HttpException } from "@/exceptions/HttpException";
import { type IOrderRepository, ORDER_REPOSITORY_TOKEN } from "@/interfaces/order/IOrderRepository.interface";
import { type IOrderService, ORDER_SERVICE_TOKEN } from "@/interfaces/order/IOrderService.interface";
import { CART_REPOSITORY_TOKEN } from "@/interfaces/cart/ICartRepository.interface";
import type { ICartRepository } from "@/interfaces/cart/ICartRepository.interface";
import { PRODUCT_REPOSITORY_TOKEN } from "@/interfaces/product/IProductRepository.interface";
import type { IProductRepository } from "@/interfaces/product/IProductRepository.interface";
import { PRODUCT_SERVICE_TOKEN } from "@/interfaces/product/IProductService.interface";
import type { IProductService } from "@/interfaces/product/IProductService.interface";
import type { IOrder, ICreateOrder, IUpdateOrder } from "@/types/order.types";
import Order from "@/models/order/order.model";
import dbConnection from "@/database";

@Service({ id: ORDER_SERVICE_TOKEN })
export class OrderService implements IOrderService {
  constructor(
    @Inject(ORDER_REPOSITORY_TOKEN) private readonly orderRepository: IOrderRepository,
    @Inject(CART_REPOSITORY_TOKEN) private readonly cartRepository: ICartRepository,
    @Inject(PRODUCT_REPOSITORY_TOKEN) private readonly productRepository: IProductRepository,
    @Inject(PRODUCT_SERVICE_TOKEN) private readonly productService: IProductService
  ) {}

  public async createOrder(userId: string, orderData: ICreateOrder): Promise<IOrder> {
    const transaction = await dbConnection.transaction();

    try {
      // Get user's cart
      const cart = await this.cartRepository.getCartWithItems(userId);
      if (!cart || !cart.items || cart.items.length === 0) {
        throw new HttpException(400, "Cart is empty");
      }

      // Create order (order number will be generated by repository)
      const order = await this.orderRepository.create(orderData);

      let totalAmount = 0;

      // Process each cart item and create order items
      for (const cartItem of cart.items) {
        // Verify product still exists and is active
        const product = await this.productRepository.findById(cartItem.productId);
        if (!product) {
          await transaction.rollback();
          throw new HttpException(404, `Product ${cartItem.productId} not found`);
        }

        if (product.status !== "Active") {
          await transaction.rollback();
          throw new HttpException(400, `Product ${product.title} is not available`);
        }

        // Determine price and stock check
        let unitPrice: number;
        let availableStock: number;

        if (cartItem.productVariantId) {
          const variant = product.variants?.find((v: any) => v.id === cartItem.productVariantId);
          if (!variant) {
            await transaction.rollback();
            throw new HttpException(404, `Product variant ${cartItem.productVariantId} not found`);
          }
          if (variant.status !== "Active") {
            await transaction.rollback();
            throw new HttpException(400, `Product variant is not available`);
          }
          // Use variant price (discount price if available, otherwise regular price)
          const variantPrice = variant.discountPrice || variant.price;
          unitPrice = typeof variantPrice === 'string' ? parseFloat(variantPrice) : variantPrice;
          availableStock = variant.stock;
        } else {
          // Use product price (discount price if available, otherwise regular price)
          // Product from repository has flat structure with regularPrice, discountPrice, initialStock
          const productPrice = (product as any).discountPrice || (product as any).regularPrice;
          unitPrice = typeof productPrice === 'string' ? parseFloat(productPrice) : productPrice;
          availableStock = (product as any).initialStock || 0;
        }

        // Check stock availability
        if (availableStock < cartItem.quantity) {
          await transaction.rollback();
          throw new HttpException(400, `Insufficient stock for ${product.title}`);
        }

        const totalPrice = unitPrice * cartItem.quantity;
        totalAmount += totalPrice;

        // Create order item
        await this.orderRepository.createOrderItem(order.id!, {
          productId: cartItem.productId,
          productVariantId: cartItem.productVariantId || null,
          quantity: cartItem.quantity,
          unitPrice,
          totalPrice,
        });
      }

      // Update order total amount using transaction
      await Order.update(
        { totalAmount },
        {
          where: { id: order.id! },
          transaction,
        }
      );

      // Clear cart after successful order creation
      await this.cartRepository.clearCart(cart.id!);

      await transaction.commit();

      // Fetch order with items
      const orderWithItems = await this.orderRepository.getOrderWithItems(order.id!);

      // Enrich order items with product details (with signed URLs)
      if (orderWithItems && orderWithItems.items) {
        const enrichedItems = await Promise.all(
          orderWithItems.items.map(async (item) => {
            const product = await this.productService.getProductById(item.productId);
            return {
              ...item,
              product: product || undefined,
            };
          })
        );
        orderWithItems.items = enrichedItems;
      }

      return orderWithItems!;
    } catch (error: any) {
      await transaction.rollback();
      if (error instanceof HttpException) {
        throw error;
      }
      throw new HttpException(500, error.message);
    }
  }

  public async getOrderById(id: string): Promise<IOrder | null> {
    try {
      const order = await this.orderRepository.getOrderWithItems(id);
      if (!order) {
        return null;
      }

      // Enrich order items with product details (with signed URLs)
      if (order.items) {
        const enrichedItems = await Promise.all(
          order.items.map(async (item) => {
            const product = await this.productService.getProductById(item.productId);
            return {
              ...item,
              product: product || undefined,
            };
          })
        );
        order.items = enrichedItems;
      }

      return order;
    } catch (error: any) {
      throw new HttpException(500, error.message);
    }
  }

  public async getOrderByOrderNumber(orderNumber: string): Promise<IOrder | null> {
    try {
      const order = await this.orderRepository.findByOrderNumber(orderNumber);
      if (!order) {
        return null;
      }

      const orderWithItems = await this.orderRepository.getOrderWithItems(order.id!);

      // Enrich order items with product details (with signed URLs)
      if (orderWithItems && orderWithItems.items) {
        const enrichedItems = await Promise.all(
          orderWithItems.items.map(async (item) => {
            const product = await this.productService.getProductById(item.productId);
            return {
              ...item,
              product: product || undefined,
            };
          })
        );
        orderWithItems.items = enrichedItems;
      }

      return orderWithItems;
    } catch (error: any) {
      throw new HttpException(500, error.message);
    }
  }

  public async getOrdersByUserId(userId: string): Promise<IOrder[]> {
    try {
      const orders = await this.orderRepository.findByUserId(userId);

      // Enrich each order with items (with signed URLs)
      const enrichedOrders = await Promise.all(
        orders.map(async (order) => {
          const orderWithItems = await this.orderRepository.getOrderWithItems(order.id!);
          if (orderWithItems && orderWithItems.items) {
            const enrichedItems = await Promise.all(
              orderWithItems.items.map(async (item) => {
                const product = await this.productService.getProductById(item.productId);
                return {
                  ...item,
                  product: product || undefined,
                };
              })
            );
            orderWithItems.items = enrichedItems;
          }
          return orderWithItems || order;
        })
      );

      return enrichedOrders;
    } catch (error: any) {
      throw new HttpException(500, error.message);
    }
  }

  public async getAllOrders(status?: string): Promise<IOrder[]> {
    try {
      const orders = await this.orderRepository.findAll(status);

      // Enrich each order with items (with signed URLs)
      const enrichedOrders = await Promise.all(
        orders.map(async (order) => {
          const orderWithItems = await this.orderRepository.getOrderWithItems(order.id!);
          if (orderWithItems && orderWithItems.items) {
            const enrichedItems = await Promise.all(
              orderWithItems.items.map(async (item) => {
                const product = await this.productService.getProductById(item.productId);
                return {
                  ...item,
                  product: product || undefined,
                };
              })
            );
            orderWithItems.items = enrichedItems;
          }
          return orderWithItems || order;
        })
      );

      return enrichedOrders;
    } catch (error: any) {
      throw new HttpException(500, error.message);
    }
  }

  public async updateOrder(updateData: IUpdateOrder): Promise<IOrder> {
    try {
      const order = await this.orderRepository.findById(updateData.id);
      if (!order) {
        throw new HttpException(404, "Order not found");
      }

      const updatedOrder = await this.orderRepository.update(updateData);

      // Fetch order with items
      const orderWithItems = await this.orderRepository.getOrderWithItems(updatedOrder.id!);

      // Enrich order items with product details
      if (orderWithItems && orderWithItems.items) {
        const enrichedItems = await Promise.all(
          orderWithItems.items.map(async (item) => {
            const product = await this.productRepository.findById(item.productId);
            return {
              ...item,
              product: product || undefined,
            };
          })
        );
        orderWithItems.items = enrichedItems;
      }

      return orderWithItems || updatedOrder;
    } catch (error: any) {
      if (error instanceof HttpException) {
        throw error;
      }
      throw new HttpException(500, error.message);
    }
  }
}
